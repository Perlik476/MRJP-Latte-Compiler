-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- | Program to test parser.

module Main where

import Prelude
import System.Environment ( getArgs )
import System.Exit        ( exitFailure, exitSuccess )
import System.IO          ( hPutStrLn, stderr, hPutStr )
import Control.Monad      ( when )

import Latte.Abs
import Latte.Lex   ( Token, mkPosToken )
import Latte.Par   ( pProgram, myLexer )
import Latte.Print ( Print, printTree )
import Latte.Skel  ()

import Data.Map (Map, empty, fromList, union, member, lookup, insert, toList, keys, difference, intersection, elems, (!), intersectionWith)
import Control.Monad.State
import Control.Monad.Except
import Control.Monad.Reader
import qualified Data.List

import Frontend (frontendCheck, showCode, getParseErrPosition)
import TreeTransformer (transformTree)
import Generator (compile)
import System.Process

import Utils (Options(..), CSE (..))

type Err        = Either String
type ParseFun a = [Token] -> Err a
type Verbosity  = Int

runFile options p f = readFile f >>= run options p f

run options p f s =
  case p ts of
    Left err -> do
      hPutStrLn stderr "ERROR"
      hPutStrLn stderr "Parse failed."
      hPutStrLn stderr err
      hPutStr stderr $ showCode s (getParseErrPosition err)
      exitFailure
    Right tree -> do
      success <- frontendCheck tree s
      if success then do
        hPutStrLn stderr "OK"
        let ast = transformTree tree
        llvm_file_content <- compile options ast
        let fll = removeExtension f ++ "ll"
        let fbc = removeExtension f ++ "bc"
        let fll' = "\"" ++ fll ++ "\""
        let fbc' = "\"" ++ fbc ++ "\""
        writeFile fll llvm_file_content
        callCommand "clang -S -emit-llvm lib/runtime_c.c -o lib/runtime_c.ll"
        callCommand "llvm-as lib/runtime_c.ll"
        callCommand "llvm-as lib/runtime.ll"
        callCommand $ "llvm-as " ++ fll'
        callCommand $ "llvm-link " ++ fbc' ++ " lib/runtime.bc lib/runtime_c.bc -o " ++ fbc'
        exitSuccess
      else do
        exitFailure
  where
  ts = myLexer s

removeExtension :: String -> String
removeExtension = reverse . dropWhile (/= '.') . reverse

usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "usage: Call with one of the following argument combinations:", 
      "  --help                                    Display this help message.",
      " (file)                                     Compile file",
      " --verbose (file)                           Compile file and print compiler messages",
      " --comments (file)                          Compile file with comments illustrating the compilation process",
      " --remove-trivial-phis=0|1 (file)           Compile file with removing trivial phis (default: 1)",
      " --remove-trivial-blocks=0|1 (file)         Compile file with removing trivial blocks (default: 1)",
      " --merge-blocks=0|1 (file)                  Compile file with merging blocks when possible (default: 1)",
      " --CSE=0|LCSE|GCSE (file)                   Compile file with common subexpression elimination (default: GCSE)",
      " --skip-trivial-conditions=0|1 (file)       Compile file with skipping trivial conditions (default: 1)"
    ]

processArgs :: [String] -> Options
processArgs = foldl processArg (Options { 
  optVerbose = False,
  optComments = False,
  optRemoveTrivialPhis = True,
  optMergeBlocks = True,
  optRemoveTrivialBlocks = True,
  optCSE = GCSE,
  optSkipTrivialConditions = True,
  optInline = True
})
  where
    processArg :: Options -> String -> Options
    processArg options "--verbose" = options { optVerbose = True }
    processArg options "--remove-trivial-phis=0" = options { optRemoveTrivialPhis = False }
    processArg options "--remove-trivial-phis=1" = options { optRemoveTrivialPhis = True }
    processArg options "--comments" = options { optComments = True }
    processArg options "--merge-blocks=0" = options { optMergeBlocks = False }
    processArg options "--merge-blocks=1" = options { optMergeBlocks = True }
    processArg options "--remove-trivial-blocks=0" = options { optRemoveTrivialBlocks = False }
    processArg options "--remove-trivial-blocks=1" = options { optRemoveTrivialBlocks = True }
    processArg options "--CSE=0" = options { optCSE = NoCSE }
    processArg options "--CSE=LCSE" = options { optCSE = LCSE }
    processArg options "--CSE=GCSE" = options { optCSE = GCSE }
    processArg options "--skip-trivial-conditions=0" = options { optSkipTrivialConditions = False }
    processArg options "--skip-trivial-conditions=1" = options { optSkipTrivialConditions = True }
    processArg options "--inline=0" = options { optInline = False }
    processArg options "--inline=1" = options { optInline = True }
    processArg options _ = options

main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> usage
    "--help" : _ -> usage
    _ -> do
      let options = processArgs args
      let files = filter (\x -> head x /= '-') args
      case files of
        [] -> usage
        _ -> do
          let file = head files
          runFile options pProgram file
