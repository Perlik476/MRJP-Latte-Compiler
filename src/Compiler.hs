-- File generated by the BNF Converter (bnfc 2.9.4.1).

-- | Program to test parser.

module Main where

import Prelude
import System.Environment ( getArgs )
import System.Exit        ( exitFailure, exitSuccess )
import System.IO          ( hPutStrLn, stderr, hPutStr )
import Control.Monad      ( when )

import Latte.Abs
import Latte.Lex   ( Token, mkPosToken )
import Latte.Par   ( pProgram, myLexer )
import Latte.Print ( Print, printTree )
import Latte.Skel  ()

import Data.Map (Map, empty, fromList, union, member, lookup, insert, toList, keys, difference, intersection, elems, (!), intersectionWith)
import Control.Monad.State
import Control.Monad.Except
import Control.Monad.Reader
import qualified Data.List

import Frontend (frontendCheck, showCode, getParseErrPosition)
import TreeTransformer (transformTree)
import Generator (compile)
import System.Process

import Utils (Options(..))

type Err        = Either String
type ParseFun a = [Token] -> Err a
type Verbosity  = Int

runFile options p f = putStrLn f >> readFile f >>= run options p f

run options p f s =
  case p ts of
    Left err -> do
      hPutStrLn stderr "ERROR"
      hPutStrLn stderr "Parse failed."
      hPutStrLn stderr err
      hPutStr stderr $ showCode s (getParseErrPosition err)
      exitFailure
    Right tree -> do
      success <- frontendCheck tree s
      if success then do
        hPutStrLn stderr "OK"
        let ast = transformTree tree
        llvm_file_content <- compile options ast
        let fll = removeExtension f ++ "ll"
        let fbc = removeExtension f ++ "bc"
        writeFile fll llvm_file_content
        callCommand "clang -S -emit-llvm lib/runtime_c.c -o lib/runtime_c.ll"
        callCommand "llvm-as lib/runtime_c.ll"
        callCommand "llvm-as lib/runtime.ll"
        callCommand $ "llvm-as " ++ fll
        callCommand $ "llvm-link " ++ fbc ++ " lib/runtime.bc lib/runtime_c.bc -o " ++ fbc
        exitSuccess
      else do
        exitFailure
  where
  ts = myLexer s

removeExtension :: String -> String
removeExtension = reverse . dropWhile (/= '.') . reverse

usage :: IO ()
usage = do
  putStrLn $ unlines
    [ "usage: Call with one of the following argument combinations:", 
      "  --help                           Display this help message.",
      " (files)                           Compile files",
      " --verbose (files)                 Compile files and print compiler messages",
      " --comments (files)                Compile files with comments illustrating the compilation process",
      " --remove-trivial-phis=0|1 (files) Compile files with removing trivial phis (default: 1)",
      " --merge-blocks=0|1 (files)        Compile files with merging blocks (default: 1)"
    ]

processArgs :: [String] -> Options
processArgs = foldl processArg (Options { 
  optVerbose = False,
  optComments = False,
  optRemoveTrivialPhis = True,
  optMergeBlocks = True
})
  where
    processArg :: Options -> String -> Options
    processArg options "--verbose" = options { optVerbose = True }
    processArg options "--remove-trivial-phis=0" = options { optRemoveTrivialPhis = False }
    processArg options "--remove-trivial-phis=1" = options { optRemoveTrivialPhis = True }
    processArg options "--comments" = options { optComments = True }
    processArg options "--merge-blocks=0" = options { optMergeBlocks = False }
    processArg options "--merge-blocks=1" = options { optMergeBlocks = True }
    processArg options _ = options

main :: IO ()
main = do
  args <- getArgs
  case args of
    [] -> usage
    "--help" : _ -> usage
    _ -> do
      let options = processArgs args
      let files = filter (\x -> head x /= '-') args
      mapM_ (runFile options pProgram) files
