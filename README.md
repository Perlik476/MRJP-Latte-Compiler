# Latte compiler

Compiler for [the Latte language](https://www.mimuw.edu.pl/~ben/Zajecia/Mrj2023/Latte/) written in Haskell. The compiler generates LLVM code.

Part of the Compiler construction course at the University of Warsaw.

## Language description

Latte is a simple language with a syntax similar to C and Java. It supports classes, objects, arrays, and strings, as well as basic control structures such as loops and conditionals. The language is statically typed and has a simple type system with basic types such as `int`, `string`, `bool`, and `void`. The language also supports functions, including recursion.

### Example programs

In the `tests/my-tests` directory, there are example programs written in the Latte language.

## Requirements

- `ghc` - Glasgow Haskell Compiler
- `alex` - lexical analyser generator
- `happy` - parser generator
- `bnfc` - Backus-Naur Form Converter
- `llvm-as` - LLVM assembler
- `llvm-link` - LLVM linker

## Building the compiler

In order to build the compiler, run `make` in the main directory of the project. After building, a file `latc_llvm` will appear in the main directory.

## Compiler options

Compiler `latc_llvm` accepts the following options:

- `--help` - prints information about compiler options
- `--verbose` - prints information about the compilation process
- `--comments` - prints comments in the LLVM code
- `--remove-trivial-phis=0|1` - removes trivial phis (default 1)
- `--CSE=0|LCSE|GCSE` - removes common subexpressions (default GCSE) (LCSE: within basic blocks; GCSE: within functions, with the exception of common subexpressions from conditional or loop blocks and expressions from their conditions)
- `--inline=0|1` - inlines functions at call sites (default 1) (with the exception of functions already inlined). Additional options are available:
    - `--inline-max-depth=n` - maximum depth of function call nesting to be inlined (default 3)
    - `--inline-max-lines=n` - maximum number of instructions in a function to be inlined (default 5) (with the exception of instructions created after the AST transformation)
- `--remove-trivial-blocks=0|1` - removes redundant blocks (default 1) (i.e. blocks containing only an unconditional jump to the next block and not used in any phi)
- `--merge-blocks=0|1` - merges blocks if possible (default 1) (i.e. if a block has only one predecessor and this predecessor has only one successor, these blocks are merged). An example of use is the following code (with the `--skip-trivial-conditions` option turned off):
```
    int foo() {
        int x = 0;
        if (x == 0) {
            return x;
        } else {
            x++;
        }
        return x;
    }
```
- `--skip-trivial-conditions=0|1` - skips trivial conditions (default 1) (e.g. `if (x == x) {...}` or `x = 0; if (x == 0) {...}`)

## Project structure

- `src` - directory containing the compiler sources
- `src/Frontend.hs` - file containing the module responsible for the compiler frontend
- `src/AST.hs` - file containing the module responsible for the AST representation
- `src/Compiler.hs` - file containing the module responsible for running the compiler with the appropriate options
- `src/Generator.hs` - file containing the module responsible for generating LLVM code
- `src/TreeTransform.hs` - file containing the module responsible for transforming the AST tree, including renaming variables
- `src/Utils.hs` - file containing the module containing auxiliary functions and data types used in the compiler backend
- `src/Latte` - directory containing files generated by BNFC
- `src/Latte.cf` - file containing the grammar of the Latte language extended with additional constructs, see the Extensions section
- `src/Makefile` - file containing the compiler build rules
- `README.md` - file containing this documentation

## Extensions

- Use of phi
- One-dimensional arrays and for loops
- Structures
- Objects
- Virtual methods
- LCSE and GCSE
- Function inlining

## Key (potentially non-standard) information about the language:

- All expressions composed of constants, arithmetic and relational operators are evaluated, and their result is used to determine the logical value of conditional expressions, which allows to determine whether functions return values in every possible case (resulting from the evaluation of conditional expressions).
- Functions, variables and classes are independent of each other, so e.g. a function can have the same name as a variable or a class. The same applies to fields and methods in classes.
- Inside classes, `self` can be used to refer to class attributes and methods, although it is not required. `self` cannot be used as a name for variables, functions or classes, including names of fields and methods.
- In the immediate function block, a variable cannot be declared with the name of a function argument, although it can be done in blocks nested within it.
- In the immediate `for` block, a variable cannot be declared with the name of the variable iterating over the collection, although it can be done in blocks nested within it.
- Correct string operations: `+`, `==`, `!=`.
- Correct number operations: `+`, `-`, `*`, `/`, `%`, `==`, `!=`, `<`, `<=`, `>`, `>=`.
- Correct operations on logical values: `==`, `!=`, `&&`, `||`.

## Additional information

- The phi generation algorithm is based on the algorithm described in the paper [Simple and Efficient Construction of Static Single Assignment Form](https://link.springer.com/content/pdf/10.1007/978-3-642-37051-9_6.pdf).